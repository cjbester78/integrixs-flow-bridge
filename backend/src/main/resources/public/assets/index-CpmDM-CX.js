import{w as l,a as n,l as c,L as p,E as m}from"./index-j6L12q1O.js";/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const T=l("TestTube",[["path",{d:"M14.5 2v17.5c0 1.4-1.1 2.5-2.5 2.5c-1.4 0-2.5-1.1-2.5-2.5V2",key:"125lnx"}],["path",{d:"M8.5 2h7",key:"csnxdl"}],["path",{d:"M14.5 16h-5",key:"1ox875"}]]);class g{async createAdapter(t){return n.post("/adapters",t)}async getAdapters(t){const e=new URLSearchParams;t&&Object.entries(t).forEach(([r,a])=>{a!==void 0&&e.append(r,a.toString())});const s=`/adapters${e.toString()?`?${e.toString()}`:""}`;return n.get(s)}async getAdapter(t){return n.get(`/adapters/${t}`)}async updateAdapter(t,e){return n.put(`/adapters/${t}`,e)}async deleteAdapter(t){return n.delete(`/adapters/${t}`)}async cloneAdapter(t,e){return n.post(`/adapters/${t}/clone`,{name:e})}}class y{async testAdapter(t,e){return n.post(`/adapters/${t}/test`,{testData:e})}async testAdapterConfiguration(t,e){return n.post("/adapters/test-config",{configuration:t,type:e})}async validateAdapterConfig(t,e){return n.post("/adapters/validate-config",{type:t,configuration:e})}}class w{websocket=null;reconnectAttempts=0;maxReconnectAttempts=5;reconnectInterval=3e3;logListeners=[];statsListeners=[];async getAdapterStats(t,e){const s=`/adapters/${t}/stats${e?`?timeRange=${e}`:""}`;return n.get(s)}async getAdapterLogs(t,e){const s=new URLSearchParams;e&&Object.entries(e).forEach(([a,i])=>{i!==void 0&&s.append(a,i.toString())});const r=`/adapters/${t}/logs${s.toString()?`?${s.toString()}`:""}`;return n.get(r)}connectWebSocket(t){if(this.websocket?.readyState===WebSocket.OPEN)return;const e=`ws://localhost:8080/ws/adapters${t?`/${t}/logs`:"/logs"}`;try{this.websocket=new WebSocket(e),this.websocket.onopen=()=>{c.info(p.API,"WebSocket connected for adapter monitoring"),this.reconnectAttempts=0},this.websocket.onmessage=s=>{try{const r=JSON.parse(s.data);r.type==="new_log"?this.logListeners.forEach(a=>a(r.log)):r.type==="stats_update"&&this.statsListeners.forEach(a=>a(r.stats))}catch(r){c.error(p.API,"Error parsing WebSocket message",{error:r})}},this.websocket.onclose=()=>{c.info(p.API,"WebSocket connection closed"),this.attemptReconnect(t)},this.websocket.onerror=s=>{c.error(p.API,"WebSocket error",{error:s})}}catch(s){c.error(p.API,"Failed to create WebSocket connection",{error:s})}}attemptReconnect(t){this.reconnectAttempts<this.maxReconnectAttempts&&(this.reconnectAttempts++,c.info(p.API,`Attempting to reconnect WebSocket (${this.reconnectAttempts}/${this.maxReconnectAttempts})`),setTimeout(()=>{this.connectWebSocket(t)},this.reconnectInterval*this.reconnectAttempts))}disconnectWebSocket(){this.websocket&&(this.websocket.close(),this.websocket=null),this.logListeners=[],this.statsListeners=[],this.reconnectAttempts=0}onLogUpdate(t){return this.logListeners.push(t),()=>{const e=this.logListeners.indexOf(t);e>-1&&this.logListeners.splice(e,1)}}onStatsUpdate(t){return this.statsListeners.push(t),()=>{const e=this.statsListeners.indexOf(t);e>-1&&this.statsListeners.splice(e,1)}}sendCommand(t,e){this.websocket?.readyState===WebSocket.OPEN&&this.websocket.send(JSON.stringify({command:t,data:e}))}}class A{async getAdapterTypes(t){const e=new URLSearchParams;t&&Object.entries(t).forEach(([r,a])=>{a!==void 0&&e.append(r,a.toString())});const s=`/adapters/types${e.toString()?`?${e.toString()}`:""}`;return n.get(s)}async getAdapterType(t){return n.get(`/adapters/types/${t}`)}async createAdapterType(t){return n.post("/adapters/types",t)}async updateAdapterType(t,e){return n.put(`/adapters/types/${t}`,e)}async deleteAdapterType(t){return n.delete(`/adapters/types/${t}`)}async cloneAdapterType(t,e){return n.post(`/adapters/types/${t}/clone`,{name:e})}async getAdapterTypesByCategory(t){return n.get(`/adapters/types?category=${t}`)}async updateAdapterTypeStatus(t,e){return n.patch(`/adapters/types/${t}/status`,{isActive:e})}async validateAdapterTypeConfiguration(t,e){return n.post("/adapters/types/validate",{configuration:t,category:e})}async searchAdapterTypes(t,e){const s=new URLSearchParams({q:t,...e?.category&&{category:e.category},...e?.isActive!==void 0&&{isActive:e.isActive.toString()},page:(e?.page||1).toString(),limit:(e?.limit||50).toString()});return n.get(`/adapters/types/search?${s}`)}async getAdapterTypeUsage(t){return n.get(`/adapters/types/${t}/usage`)}}class f{mockServers=new Map;async validateAdapter(t){const e=Date.now(),s=[],r=[],a=[];try{const i=this.validateConfiguration(t);i.isValid||(s.push(...i.errors),r.push(...i.warnings)),await this.setupMockServers(t.adapterType);for(const d of t.testScenarios){const u=await this.runTestScenario(t,d);a.push(u),u.status==="failed"&&s.push(`Test '${d.name}' failed: ${u.message}`)}await this.cleanupMockServers(t.adapterType);const h=Date.now()-e;return m({title:"Adapter Validation Complete",description:`${a.length} tests completed in ${h}ms`,variant:a.some(d=>d.status==="failed")?"destructive":"default"}),{isValid:s.length===0,errors:s,warnings:r,testResults:a}}catch(i){return s.push(`Validation failed: ${i instanceof Error?i.message:"Unknown error"}`),{isValid:!1,errors:s,warnings:r,testResults:a}}}validateConfiguration(t){const e=[],s=[],r=this.getRequiredFields(t.adapterType);for(const a of r)t.configuration[a]||e.push(`Required field '${a}' is missing`);switch(t.adapterType){case"http_sender":case"http_receiver":this.validateHttpConfiguration(t.configuration,e,s);break;case"ftp":case"sftp":this.validateFtpConfiguration(t.configuration,e,s);break;case"jdbc_sender":case"jdbc_receiver":this.validateJdbcConfiguration(t.configuration,e,s);break;case"soap_sender":case"soap_receiver":this.validateSoapConfiguration(t.configuration,e,s);break}return{isValid:e.length===0,errors:e,warnings:s}}validateHttpConfiguration(t,e,s){if(t.url)try{new URL(t.url)}catch{e.push("Invalid URL format")}t.authentication==="basic"&&(!t.username||!t.password)&&e.push("Username and password required for basic authentication"),t.timeout&&(t.timeout<1e3||t.timeout>3e5)&&s.push("Timeout should be between 1000ms and 300000ms")}validateFtpConfiguration(t,e,s){t.host||e.push("FTP host is required"),t.port&&(t.port<1||t.port>65535)&&e.push("Invalid port number"),t.username||s.push("Anonymous FTP access may not be secure")}validateJdbcConfiguration(t,e,s){t.connectionUrl||e.push("JDBC connection URL is required"),t.driverClass||e.push("JDBC driver class is required"),t.connectionUrl&&!t.connectionUrl.startsWith("jdbc:")&&e.push("Invalid JDBC URL format")}validateSoapConfiguration(t,e,s){if(!t.wsdlUrl&&!t.endpointUrl&&e.push("Either WSDL URL or endpoint URL is required"),t.wsdlUrl)try{new URL(t.wsdlUrl)}catch{e.push("Invalid WSDL URL format")}}async runTestScenario(t,e){const s=Date.now();try{switch(e.type){case"connection":return await this.testConnection(t,e);case"authentication":return await this.testAuthentication(t,e);case"data_transmission":return await this.testDataTransmission(t,e);case"error_handling":return await this.testErrorHandling(t,e);default:throw new Error(`Unknown test scenario type: ${e.type}`)}}catch(r){return{testName:e.name,status:"failed",message:r instanceof Error?r.message:"Unknown error",duration:Date.now()-s}}}async testConnection(t,e){const s=Date.now();await new Promise(i=>setTimeout(i,1e3));const a=this.mockServers.get(t.adapterType)?.isRunning()??!0;return{testName:e.name,status:a?"passed":"failed",message:a?"Connection successful":"Connection failed",duration:Date.now()-s}}async testAuthentication(t,e){const s=Date.now();await new Promise(a=>setTimeout(a,800));const r=t.configuration.username&&t.configuration.password;return{testName:e.name,status:r?"passed":"failed",message:r?"Authentication successful":"Authentication failed",duration:Date.now()-s}}async testDataTransmission(t,e){const s=Date.now();return await new Promise(r=>setTimeout(r,1500)),{testName:e.name,status:"passed",message:"Data transmission successful",duration:Date.now()-s}}async testErrorHandling(t,e){const s=Date.now();return await new Promise(r=>setTimeout(r,600)),{testName:e.name,status:"passed",message:"Error handling working correctly",duration:Date.now()-s}}async setupMockServers(t){const e=new v(t);await e.start(),this.mockServers.set(t,e)}async cleanupMockServers(t){const e=this.mockServers.get(t);e&&(await e.stop(),this.mockServers.delete(t))}getRequiredFields(t){return{http_sender:["url","method"],http_receiver:["port"],ftp:["host","port"],sftp:["host","port","username"],jdbc_sender:["connectionUrl","driverClass"],jdbc_receiver:["connectionUrl","driverClass"],soap_sender:["wsdlUrl"],soap_receiver:["wsdlUrl"],rest_sender:["url","method"],rest_receiver:["port"],jms_sender:["connectionFactory","destination"],jms_receiver:["connectionFactory","destination"],mail_sender:["smtpHost","port"],mail_receiver:["host","port"],file:["directory"],rfc_sender:["host","systemNumber"],rfc_receiver:["host","systemNumber"],idoc_sender:["host","systemNumber"],idoc_receiver:["host","systemNumber"],odata_sender:["serviceUrl"],odata_receiver:["serviceUrl"]}[t]||[]}}class v{constructor(t){this.adapterType=t}running=!1;async start(){await new Promise(t=>setTimeout(t,500)),this.running=!0}async stop(){this.running=!1}isRunning(){return this.running}}const S=new f;class b{api;testing;monitoring;types;constructor(){this.api=new g,this.testing=new y,this.monitoring=new w,this.types=new A}async createAdapter(...t){return this.api.createAdapter(...t)}async getAdapters(...t){return this.api.getAdapters(...t)}async getAdapter(...t){return this.api.getAdapter(...t)}async updateAdapter(...t){return this.api.updateAdapter(...t)}async deleteAdapter(...t){return this.api.deleteAdapter(...t)}async cloneAdapter(...t){return this.api.cloneAdapter(...t)}async testAdapter(...t){return this.testing.testAdapter(...t)}async testAdapterConfiguration(...t){return this.testing.testAdapterConfiguration(...t)}async validateAdapterConfig(...t){return this.testing.validateAdapterConfig(...t)}async getAdapterStats(...t){return this.monitoring.getAdapterStats(...t)}async getAdapterLogs(...t){return this.monitoring.getAdapterLogs(...t)}async getAdapterTypes(...t){return this.types.getAdapterTypes(...t)}async validateAdapter(t){return S.validateAdapter(t)}}const $=new b;export{T,S as a,$ as b};
