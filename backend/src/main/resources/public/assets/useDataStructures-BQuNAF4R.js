import{r as U}from"./react-vendor-pDgKdaAw.js";import{l as t,L as r,F as k}from"./index-j6L12q1O.js";import{s as R}from"./structureService-DHD3fE3P.js";const _=E=>{try{const u=JSON.parse(E);return q(u)}catch{return null}},q=E=>{if(Array.isArray(E))return E.length>0?["array",q(E[0])]:"array";if(E!==null&&typeof E=="object"){const u={};for(const[d,w]of Object.entries(E))u[d]=q(w);return u}else return typeof E},F=E=>{try{const d=new DOMParser().parseFromString(E,"text/xml");if(d.querySelector("parsererror"))return null;const N=[],b=new Map,c=(g,f)=>{const s=g.split(":").pop()||"";if(b.has(s))return b.get(s);for(const p of f){const h=p.querySelector(`complexType[name="${s}"], xs\\:complexType[name="${s}"], xsd\\:complexType[name="${s}"]`);if(h){const m={};return S(h,m,0,f),b.set(s,m),m}const x=p.querySelector(`simpleType[name="${s}"], xs\\:simpleType[name="${s}"], xsd\\:simpleType[name="${s}"]`);if(x){const m=x.querySelector("restriction, xs\\:restriction, xsd\\:restriction");if(m)return(m.getAttribute("base")||"string").replace(/^(xs:|xsd:|tns:)/,"")}}return s.replace(/^(xs:|xsd:|tns:)/,"")},v=g=>{const f={};for(const[s,p]of g)f[s]=p;return f},S=(g,f,s=0,p)=>{const h=g.querySelectorAll(":scope > sequence > element, :scope > sequence > xs\\:element, :scope > sequence > xsd\\:element, :scope > element, :scope > xs\\:element, :scope > xsd\\:element"),x=[];h.forEach(m=>{const I=m.getAttribute("name"),T=m.getAttribute("type"),O=m.getAttribute("ref"),A=m.getAttribute("maxOccurs"),L=A==="unbounded"||A&&parseInt(A)>1;if(I||O){const C=I||O?.split(":").pop()||"",B=L?`${C}[]`:C;let n;const o=m.querySelector("complexType, xs\\:complexType, xsd\\:complexType");if(o){const D={};S(o,D,s+1,p),n=D}else if(T)n=c(T,p);else if(O){const D=O.split(":").pop()||"";for(const $ of p){const G=$.querySelector(`element[name="${D}"], xs\\:element[name="${D}"], xsd\\:element[name="${D}"]`);if(G){const M=G.getAttribute("type");M&&(n=c(M,p));break}}n||(n="string")}else n="string";x.push([B,n])}});for(const[m,I]of x)f[m]=I},i=d.querySelectorAll("schema, xs\\:schema, xsd\\:schema");d.querySelectorAll("message, wsdl\\:message").forEach(g=>{g.querySelectorAll("part, wsdl\\:part").forEach(s=>{const p=s.getAttribute("element");if(p){const h=p.split(":").pop();for(const x of i){const m=x.querySelector(`element[name="${h}"], xs\\:element[name="${h}"], xsd\\:element[name="${h}"]`);if(m){const I=m.getAttribute("type");if(I){const T=c(I,i);typeof T=="object"?N.push([h,T]):N.push([h,{value:T}])}else{const T=m.querySelector("complexType, xs\\:complexType, xsd\\:complexType");if(T){const O={};S(T,O,0,i),N.push([h,O])}}break}}}})}),N.length===0&&i.forEach(g=>{g.querySelectorAll(":scope > element, :scope > xs\\:element, :scope > xsd\\:element").forEach(s=>{const p=s.getAttribute("name");if(p){const h=s.getAttribute("type");if(h){const x=c(h,i);typeof x=="object"?N.push([p,x]):N.push([p,{value:x}])}else{const x=s.querySelector("complexType, xs\\:complexType, xsd\\:complexType");if(x){const m={};S(x,m,0,i),N.push([p,m])}}}})});const y=v(N),e=d.querySelectorAll("operation, wsdl\\:operation");let a=null;if(e.length>0){const g=e[0],f=!!g.querySelector("input, wsdl\\:input"),s=!!g.querySelector("output, wsdl\\:output"),p=!!g.querySelector("fault, wsdl\\:fault");a={hasInput:f,hasOutput:s,hasFault:p,isSynchronous:f&&s,messageTypes:[]},f&&a.messageTypes.push("input"),s&&a.messageTypes.push("output"),p&&a.messageTypes.push("fault")}return Object.keys(y).length>0?{structure:y,operationInfo:a}:null}catch(u){return t.error(r.ERROR,"Error parsing WSDL",{error:u}),null}},W=E=>{try{const d=new DOMParser().parseFromString(E,"text/xml"),w=d.querySelector("parsererror");if(w)return t.error(r.ERROR,"WSDL parsing error",{error:w}),{names:[],hasMultiple:!1};const N=d.documentElement;t.info(r.SYSTEM,"WSDL root element",{data:N.tagName,namespace:N.namespaceURI});const b=[],c=d.getElementsByTagName("*");for(let i=0;i<c.length;i++){const l=c[i];(l.localName==="portType"||l.tagName==="portType"||l.tagName==="wsdl:portType")&&b.push(l)}t.info(r.SYSTEM,"Found portTypes",{data:b.length});const v=[];b.forEach(i=>{const l=i.getElementsByTagName("*");for(let y=0;y<l.length;y++){const e=l[y];(e.localName==="operation"||e.tagName==="operation"||e.tagName==="wsdl:operation")&&e.parentElement===i&&v.push(e)}});const S=[];if(t.info(r.SYSTEM,"Found operations in portType",{data:v.length}),v.forEach(i=>{const l=i.getAttribute("name");t.info(r.SYSTEM,"Operation element",{tagName:i.tagName,nameAttribute:l}),l&&!S.includes(l)&&(S.push(l),t.info(r.SYSTEM,"Added operation",{data:l}))}),S.length===0){t.info(r.SYSTEM,"No operations in portType, checking binding elements...");const i=[];for(let l=0;l<c.length;l++){const y=c[l];(y.localName==="binding"||y.tagName==="binding"||y.tagName==="wsdl:binding")&&i.push(y)}t.info(r.SYSTEM,"Found bindings",{data:i.length}),i.forEach(l=>{const y=l.getElementsByTagName("*");for(let e=0;e<y.length;e++){const a=y[e];if((a.localName==="operation"||a.tagName==="operation"||a.tagName==="wsdl:operation")&&a.parentElement===l){const g=a.getAttribute("name");g&&!S.includes(g)&&(S.push(g),t.info(r.SYSTEM,"Found operation in binding",{data:g}))}}})}return{names:S,hasMultiple:S.length>1}}catch(u){return t.error(r.ERROR,"Error extracting WSDL operations",{error:u}),{names:[],hasMultiple:!1}}},J=E=>{try{const{names:u,hasMultiple:d}=W(E);return t.info(r.SYSTEM,"WSDL operation extraction result",{names:u,hasMultiple:d}),u.length===1?u[0]:(u.length>1,null)}catch(u){return t.error(r.ERROR,"Error extracting WSDL part name",{error:u}),null}},z=E=>{try{const d=new DOMParser().parseFromString(E,"text/xml");if(d.querySelector("parsererror"))return null;const N=d.documentElement,b=N.getAttribute("targetNamespace")||"",c=d.querySelectorAll("address, soap\\:address, soap12\\:address");let v="";c.length>0&&(v=c[0].getAttribute("location")||"");let S="";for(let i=0;i<N.attributes.length;i++){const l=N.attributes[i];if(l.name.startsWith("xmlns:")&&l.value===b){S=l.name.replace("xmlns:","");break}}return{uri:b,prefix:S,targetNamespace:b,schemaLocation:v}}catch{return null}},H=E=>{try{const d=new DOMParser().parseFromString(E,"text/xml"),w=d.querySelector("parsererror");if(w)return t.error(r.ERROR,"WSDL parsing error",{error:w}),[];const N=[],b=d.getElementsByTagName("*"),c=[];for(let S=0;S<b.length;S++){const i=b[S];(i.localName==="binding"||i.tagName==="binding"||i.tagName==="wsdl:binding")&&c.push(i)}return c.forEach(S=>{const i=S.getElementsByTagName("*");for(let l=0;l<i.length;l++){const y=i[l];if((y.localName==="operation"||y.tagName==="operation"||y.tagName==="wsdl:operation")&&y.parentElement===S){const e=y.getAttribute("name");if(e){const a=y.getElementsByTagName("*");for(let g=0;g<a.length;g++){const f=a[g];if(f.localName==="operation"&&(f.namespaceURI==="http://schemas.xmlsoap.org/wsdl/soap/"||f.namespaceURI==="http://schemas.xmlsoap.org/wsdl/soap12/")){const s=f.getAttribute("soapAction");s!==null&&N.push({operationName:e,soapAction:s})}}}}}}),N.filter((S,i,l)=>i===l.findIndex(y=>y.operationName===S.operationName))}catch(u){return t.error(r.ERROR,"Error extracting SOAP actions",{error:u}),[]}},P=E=>{const u={};return E.forEach(d=>{d.children&&d.children.length>0?u[d.name]=P(d.children):u[d.name]=d.type}),u},Y=[{id:"1",name:"Business Component Order",type:"json",description:"Standard businessComponent order structure",structure:{orderId:"string",businessComponentId:"string",items:"array",totalAmount:"decimal",orderDate:"datetime"},createdAt:"2024-01-15",usage:"source"},{id:"2",name:"Payment Response",type:"soap",description:"Payment gateway response format",structure:{transactionId:"string",status:"string",amount:"decimal",currency:"string"},createdAt:"2024-01-10",usage:"target"},{id:"3",name:"Business Component Profile",type:"json",description:"Detailed businessComponent profile with nested address information",structure:{businessComponent:{id:"string",firstName:"string",lastName:"string",email:"string",phone:"string",dateOfBirth:"date",address:{street:"string",city:"string",state:"string",zipCode:"string",country:"string"},preferences:{newsletter:"boolean",smsNotifications:"boolean",language:"string"}}},createdAt:"2024-01-12",usage:"source"},{id:"4",name:"Product Catalog",type:"json",description:"Product information with categories and pricing",structure:{products:{id:"string",name:"string",description:"string",category:{id:"string",name:"string",parentCategory:"string"},pricing:{basePrice:"decimal",currency:"string",discountPercentage:"decimal",taxRate:"decimal"},inventory:{quantity:"integer",warehouse:"string",lastUpdated:"datetime"},specifications:{weight:"decimal",dimensions:{length:"decimal",width:"decimal",height:"decimal"},color:"string",material:"string"}}},createdAt:"2024-01-08",usage:"source"},{id:"5",name:"Invoice Data",type:"xsd",description:"Standard invoice format for accounting systems",structure:{invoice:{header:{invoiceNumber:"string",invoiceDate:"date",dueDate:"date",currency:"string"},vendor:{vendorId:"string",companyName:"string",address:{street:"string",city:"string",postalCode:"string",country:"string"},taxId:"string"},businessComponent:{businessComponentId:"string",companyName:"string",contactPerson:"string",address:{street:"string",city:"string",postalCode:"string",country:"string"}},lineItems:{item:{lineNumber:"integer",productId:"string",description:"string",quantity:"decimal",unitPrice:"decimal",taxAmount:"decimal",lineTotal:"decimal"}},totals:{subtotal:"decimal",totalTax:"decimal",totalAmount:"decimal"}}},createdAt:"2024-01-05",usage:"target"},{id:"6",name:"Sales Report",type:"json",description:"Comprehensive sales reporting structure",structure:{report:{metadata:{reportId:"string",generatedAt:"datetime",period:{startDate:"date",endDate:"date"},reportType:"string"},summary:{totalSales:"decimal",totalOrders:"integer",averageOrderValue:"decimal",topProducts:{productId:"string",productName:"string",salesCount:"integer",revenue:"decimal"}},salesData:{daily:{date:"date",orders:"integer",revenue:"decimal",customers:"integer"},byRegion:{region:"string",orders:"integer",revenue:"decimal",growthRate:"decimal"}}}},createdAt:"2024-01-03",usage:"target"},{id:"7",name:"Employee Record",type:"custom",description:"HR system employee data structure",structure:{employee:{personalInfo:{employeeId:"string",firstName:"string",lastName:"string",middleName:"string",dateOfBirth:"date",ssn:"string",address:{home:{street:"string",city:"string",state:"string",zipCode:"string"},mailing:{street:"string",city:"string",state:"string",zipCode:"string"}}},employment:{hireDate:"date",department:"string",position:"string",manager:"string",salary:{amount:"decimal",currency:"string",payFrequency:"string"},benefits:{healthInsurance:"boolean",dentalInsurance:"boolean",retirement401k:"boolean",vacationDays:"integer"}}}},createdAt:"2024-01-01",usage:"source"}],K=()=>{const[E,u]=U.useState([]),[d,w]=U.useState(null),[N,b]=U.useState(!1),{toast:c}=k(),v=U.useCallback(async()=>{try{b(!0),t.info(r.BUSINESS_LOGIC,"Loading data structures from backend...");const e=await R.getStructures();if(e.success&&e.data){t.info(r.BUSINESS_LOGIC,"API structures loaded",{data:e.data.structures||e.data});const a=e.data.structures||e.data||[];if(typeof a=="string"&&a.includes("<!DOCTYPE html>")){t.info(r.BUSINESS_LOGIC,"API endpoint not implemented yet, showing sample data"),u(Y),c({title:"Info",description:"Data structures API not available yet. Showing sample data."});return}t.info(r.BUSINESS_LOGIC,`API returned ${a.length} structures`),u(a)}else t.info(r.BUSINESS_LOGIC,"API failed, showing empty list"),u([])}catch(e){t.error(r.BUSINESS_LOGIC,"Error loading structures, showing empty list",{error:e}),u([])}finally{b(!1)}},[c]);return U.useEffect(()=>{v()},[v]),{structures:E,selectedStructure:d,setSelectedStructure:w,saveStructure:async(e,a,g,f,s,p,h,x,m,I,T)=>{if(!e)return c({title:"Validation Error",description:"Please provide a structure name",variant:"destructive"}),!1;let O={};const A={};if(f)O=_(f);else if(h){const n=F(h);n&&typeof n=="object"&&"structure"in n?(O=n.structure,n.operationInfo&&(A.operationInfo=n.operationInfo)):O=n}else if(s)O={message:"XSD parsing not fully implemented yet"};else if(p)O={message:"EDMX parsing not fully implemented yet"};else if(x.length>0)O=P(x);else return c({title:"Validation Error",description:"Please define a structure using JSON, XSD, EDMX, WSDL, or custom fields",variant:"destructive"}),!1;let L,C;f?(L=f,C="json"):h?(L=h,C="xml"):s?(L=s,C="xml"):p&&(L=p,C="xml");const B={name:e,type:f?"json":h?"wsdl":s?"xsd":"custom",description:a,usage:g,structure:O,originalContent:L,originalFormat:C,businessComponentId:T,namespace:(m==="xsd"||m==="wsdl"||m==="edmx")&&I.uri?I:void 0,metadata:Object.keys(A).length>0?A:void 0};try{t.info(r.BUSINESS_LOGIC,"Saving structure to backend",{data:B});const n=await R.createStructure(B);return n.success&&n.data?(t.info(r.BUSINESS_LOGIC,"Structure saved successfully",{data:n.data}),await v(),c({title:"Structure Saved",description:`Data structure "${e}" has been created successfully`}),!0):(t.error(r.BUSINESS_LOGIC,"Failed to save structure",{error:n.error}),c({title:"Save Failed",description:"Failed to save data structure to the backend",variant:"destructive"}),!1)}catch(n){t.error(r.BUSINESS_LOGIC,"Error saving structure",{error:n});let o="An error occurred while saving the data structure";return n.response?(t.error(r.BUSINESS_LOGIC,"Error response data",{error:n.response}),n.response.detail?o=n.response.detail:n.response.message?o=n.response.message:n.response.error?o=n.response.error:typeof n.response=="string"&&(o=n.response)):n.message&&(o=n.message),c({title:"Save Error",description:o,variant:"destructive"}),!1}},updateStructure:async(e,a,g,f,s,p,h,x,m,I,T,O)=>{if(!a)return c({title:"Validation Error",description:"Please provide a structure name",variant:"destructive"}),!1;let A={};const L={};if(s)A=_(s);else if(x){const o=F(x);o&&typeof o=="object"&&"structure"in o?(A=o.structure,o.operationInfo&&(L.operationInfo=o.operationInfo)):A=o}else if(p)A={message:"XSD parsing not fully implemented yet"};else if(h)A={message:"EDMX parsing not fully implemented yet"};else if(m.length>0)A=P(m);else return c({title:"Validation Error",description:"Please define a structure using JSON, XSD, EDMX, WSDL, or custom fields",variant:"destructive"}),!1;let C,B;s?(C=s,B="json"):x?(C=x,B="xml"):p?(C=p,B="xml"):h&&(C=h,B="xml");const n={name:a,type:s?"json":x?"wsdl":p?"xsd":"custom",description:g,usage:f,structure:A,originalContent:C,originalFormat:B,businessComponentId:O,namespace:(I==="xsd"||I==="wsdl"||I==="edmx")&&T.uri?T:void 0,metadata:Object.keys(L).length>0?L:void 0};try{t.info(r.BUSINESS_LOGIC,"Updating structure:",{data:e,updates:n});const o=await R.updateStructure(e,n);return o.success&&o.data?(t.info(r.BUSINESS_LOGIC,"Structure updated successfully",{data:o.data}),await v(),c({title:"Structure Updated",description:`Data structure "${a}" has been updated successfully`}),!0):(t.error(r.BUSINESS_LOGIC,"Failed to update structure",{error:o.error}),c({title:"Update Failed",description:"Failed to update data structure",variant:"destructive"}),!1)}catch(o){t.error(r.BUSINESS_LOGIC,"Error updating structure",{error:o});let D="An error occurred while updating the data structure";return o.response?(t.error(r.BUSINESS_LOGIC,"Error response data",{error:o.response}),o.response.detail?D=o.response.detail:o.response.message?D=o.response.message:o.response.error?D=o.response.error:typeof o.response=="string"&&(D=o.response)):o.message&&(D=o.message),c({title:"Update Error",description:D,variant:"destructive"}),!1}},deleteStructure:async e=>{try{t.info(r.BUSINESS_LOGIC,"Deleting structure",{data:e});const a=await R.deleteStructure(e);a.success?(t.info(r.BUSINESS_LOGIC,"Structure deleted successfully"),await v(),d?.id===e&&w(null),c({title:"Structure Deleted",description:"Data structure has been removed"})):(t.error(r.BUSINESS_LOGIC,"Failed to delete structure",{error:a.error}),c({title:"Delete Failed",description:"Failed to delete data structure",variant:"destructive"}))}catch(a){t.error(r.BUSINESS_LOGIC,"Error deleting structure",{error:a}),c({title:"Delete Error",description:"An error occurred while deleting the data structure",variant:"destructive"})}},duplicateStructure:async e=>{try{t.info(r.BUSINESS_LOGIC,"Duplicating structure",{data:e.name});const a=await R.cloneStructure(e.id,`${e.name} (Copy)`);a.success&&a.data?(t.info(r.BUSINESS_LOGIC,"Structure duplicated successfully",{data:a.data}),await v(),c({title:"Structure Duplicated",description:`Created copy of "${e.name}"`})):(t.error(r.BUSINESS_LOGIC,"Failed to duplicate structure",{error:a.error}),c({title:"Duplicate Failed",description:"Failed to duplicate data structure",variant:"destructive"}))}catch(a){t.error(r.BUSINESS_LOGIC,"Error duplicating structure",{error:a}),c({title:"Duplicate Error",description:"An error occurred while duplicating the data structure",variant:"destructive"})}},loading:N,refreshStructures:v}};export{W as a,J as b,z as c,F as d,H as e,P as f,_ as p,K as u};
