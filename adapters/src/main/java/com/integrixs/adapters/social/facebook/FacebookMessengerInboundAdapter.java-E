package com.integrixs.adapters.social.facebook;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.integrixs.adapters.core.AbstractInboundAdapter;
import com.integrixs.shared.dto.MessageDTO;
import java.util.Map;
import java.util.HashMap;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.client.RestTemplate;
import org.springframework.http.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.context.ApplicationEventPublisher;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Inbound adapter for Facebook Messenger Platform integration.
 * Handles webhook events, message polling, and conversation management.
 */
@Component
@ConditionalOnProperty(name = "integrixs.adapters.facebook.messenger.enabled", havingValue = "true", matchIfMissing = false)
public class FacebookMessengerInboundAdapter extends AbstractInboundAdapter {
    private static final Logger log = LoggerFactory.getLogger(FacebookMessengerInboundAdapter.class);


    private Map<String, Object> configuration = new HashMap<>();
    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;
    private final ApplicationEventPublisher eventPublisher;
    private final Set<String> processedMessages = ConcurrentHashMap.newKeySet();
    private final Set<String> processedPostbacks = ConcurrentHashMap.newKeySet();

    @Autowired
    public FacebookMessengerInboundAdapter(RestTemplate restTemplate, ObjectMapper objectMapper,
                                         ApplicationEventPublisher eventPublisher) {
        this.restTemplate = restTemplate;
        this.objectMapper = objectMapper;
        this.eventPublisher = eventPublisher;
    }

    @Override
    protected Map<String, Object> getConfig() {
        return configuration;
    }

    @Override
    public Map<String, Object> getAdapterConfig() {
        return configuration;
    }

    /**
     * Polls for recent conversations and messages
     */
    @Scheduled(fixedDelayString = "$ {integrixs.adapters.facebook.messenger.polling.interval:60000}")
    public void pollMessages() {
        if(!Boolean.TRUE.equals(configuration.get("pollingEnabled"))) {
            return;
        }

        try {
            log.debug("Polling Facebook Messenger messages");
            pollConversations();
        } catch(Exception e) {
            log.error("Error polling Facebook Messenger messages", e);
        }
    }

    /**
     * Polls for message insights and analytics
     */
    @Scheduled(fixedDelayString = "$ {integrixs.adapters.facebook.messenger.polling.insights - interval:3600000}")
    public void pollInsights() {
        if(!Boolean.TRUE.equals(configuration.get("enableMessageInsights"))) {
            return;
        }

        try {
            log.debug("Polling Facebook Messenger insights");
            fetchInsights();
        } catch(Exception e) {
            log.error("Error polling Facebook Messenger insights", e);
        }
    }

    private void pollConversations() throws Exception {
        String url = (String) configuration.get("apiUrl") + "/" + (String) configuration.get("pageId") + "/conversations";
        Map<String, String> params = new HashMap<>();
        params.put("access_token", (String) configuration.get("pageAccessToken"));
        params.put("fields", "id,participants,updated_time,messages {id,from,to,message,attachments,created_time}");
        params.put("limit", "25");

        String response = makeGetRequest(url, params);
        Map<String, Object> responseData = parseJsonResponse(response);

        if(responseData.containsKey("data")) {
            List<Map<String, Object>> conversations = (List<Map<String, Object>>) responseData.get("data");
            for(Map<String, Object> conversation : conversations) {
                processConversation(conversation);
            }
        }

        // Handle pagination
        handlePagination(responseData);
    }

    private void processConversation(Map<String, Object> conversation) {
        String conversationId = (String) conversation.get("id");

        if(conversation.containsKey("messages")) {
            Map<String, Object> messagesData = (Map<String, Object>) conversation.get("messages");
            if(messagesData.containsKey("data")) {
                List<Map<String, Object>> messages = (List<Map<String, Object>>) messagesData.get("data");
                for(Map<String, Object> message : messages) {
                    processMessage(message, conversationId);
                }
            }
        }
    }

    private void processMessage(Map<String, Object> messageData, String conversationId) {
        String messageId = (String) messageData.get("id");

        if(!processedMessages.add(messageId)) {
            return; // Already processed
        }

        FacebookMessengerMessageDTO message = new FacebookMessengerMessageDTO();
        message.messageId = messageId;
        message.conversationId = conversationId;
        message.from = extractUserInfo((Map<String, Object>) messageData.get("from"));
        message.to = extractUserInfo((Map<String, Object>) messageData.get("to"));
        message.text = (String) messageData.get("message");
        message.attachments = extractAttachments((List<Map<String, Object>>) messageData.get("attachments"));
        message.timestamp = (String) messageData.get("created_time");

        publishMessage("messenger.message.received", message);
    }

    private void fetchInsights() throws Exception {
        String url = (String) configuration.get("apiUrl") + "/" + (String) configuration.get("pageId") + "/insights";
        Map<String, String> params = new HashMap<>();
        params.put("access_token", (String) configuration.get("pageAccessToken"));
        params.put("metric", String.join(",", Arrays.asList(
                "page_messages_total_messaging_connections",
                "page_messages_new_conversations_unique",
                "page_messages_blocked_conversations_unique",
                "page_messages_reported_conversations_unique"
       )));
        params.put("period", "day");

        String response = makeGetRequest(url, params);
        Map<String, Object> responseData = parseJsonResponse(response);

        if(responseData.containsKey("data")) {
            List<Map<String, Object>> insights = (List<Map<String, Object>>) responseData.get("data");
            processInsights(insights);
        }
    }

    private void processInsights(List<Map<String, Object>> insights) {
        for(Map<String, Object> insight : insights) {
            String metricName = (String) insight.get("name");
            List<Map<String, Object>> values = (List<Map<String, Object>>) insight.get("values");

            for(Map<String, Object> value : values) {
                FacebookMessengerInsight insightData = new FacebookMessengerInboundAdapter.FacebookMessengerInsight();
        insightData.metric = metricName;
        insightData.value = value.get("value");
        insightData.endTime = (String) value.get("end_time");
                publishMessage("messenger.insights.received", insightData);
            }
        }
    }

    @Override
    public void processWebhookEvent(Map<String, Object> event) {
        String object = (String) event.get("object");

        if("page".equals(object)) {
            List<Map<String, Object>> entries = (List<Map<String, Object>>) event.get("entry");
            for(Map<String, Object> entry : entries) {
                processPageEntry(entry);
            }
        }
    }

    private void processPageEntry(Map<String, Object> entry) {
        String pageId = String.valueOf(entry.get("id"));
        Long timestamp = ((Number) entry.get("time")).longValue();

        if(entry.containsKey("messaging")) {
            List<Map<String, Object>> messagingEvents = (List<Map<String, Object>>) entry.get("messaging");
            for(Map<String, Object> messagingEvent : messagingEvents) {
                processMessagingEvent(messagingEvent, pageId, timestamp);
            }
        }
    }

    private void processMessagingEvent(Map<String, Object> event, String pageId, Long timestamp) {
        Map<String, Object> sender = (Map<String, Object>) event.get("sender");
        Map<String, Object> recipient = (Map<String, Object>) event.get("recipient");

        if(event.containsKey("message")) {
            processWebhookMessage(event, sender, recipient, timestamp);
        } else if(event.containsKey("postback")) {
            processWebhookPostback(event, sender, recipient, timestamp);
        } else if(event.containsKey("referral")) {
            processWebhookReferral(event, sender, recipient, timestamp);
        } else if(event.containsKey("optin")) {
            processWebhookOptin(event, sender, recipient, timestamp);
        } else if(event.containsKey("delivery")) {
            processWebhookDelivery(event, sender, recipient, timestamp);
        } else if(event.containsKey("read")) {
            processWebhookRead(event, sender, recipient, timestamp);
        } else if(event.containsKey("reaction")) {
            processWebhookReaction(event, sender, recipient, timestamp);
        }
    }

    private void processWebhookMessage(Map<String, Object> event, Map<String, Object> sender,
                                       Map<String, Object> recipient, Long timestamp) {
        Map<String, Object> messageData = (Map<String, Object>) event.get("message");
        String messageId = (String) messageData.get("mid");

        if(!processedMessages.add(messageId)) {
            return; // Already processed
        }

        FacebookMessengerMessageDTO message = new FacebookMessengerInboundAdapter.FacebookMessengerMessageDTO();
        message.messageId = messageId;
        message.from = extractUserInfo(sender);
        message.to = extractUserInfo(recipient);
        message.text = (String) messageData.get("text");
        message.attachments = extractAttachments((List<Map<String, Object>>) messageData.get("attachments"));
        message.quickReplies = extractQuickReplies((List<Map<String, Object>>) messageData.get("quick_replies"));
        message.replyTo = (String) messageData.get("reply_to");
        message.isEcho = Boolean.TRUE.equals(messageData.get("is_echo"));
        message.timestamp = String.valueOf(timestamp);
        publishMessage("messenger.message.webhook", message);
    }

    private void processWebhookPostback(Map<String, Object> event, Map<String, Object> sender,
                                        Map<String, Object> recipient, Long timestamp) {
        Map<String, Object> postbackData = (Map<String, Object>) event.get("postback");
        String payload = (String) postbackData.get("payload");
        String postbackId = sender.get("id") + "_" + payload + "_" + timestamp;

        if(!processedPostbacks.add(postbackId)) {
            return; // Already processed
        }

        FacebookMessengerPostback postback = new FacebookMessengerInboundAdapter.FacebookMessengerPostback();
        postback.senderId = (String) sender.get("id");
        postback.recipientId = (String) recipient.get("id");
        postback.payload = payload;
        postback.title = (String) postbackData.get("title");
        postback.referral = extractReferral((Map<String, Object>) postbackData.get("referral"));
        postback.timestamp = String.valueOf(timestamp);
        publishMessage("messenger.postback.received", postback);
    }

    private void processWebhookReferral(Map<String, Object> event, Map<String, Object> sender,
                                        Map<String, Object> recipient, Long timestamp) {
        Map<String, Object> referralData = (Map<String, Object>) event.get("referral");

        FacebookMessengerReferral referral = extractReferral(referralData);
        referral.setSenderId((String) sender.get("id"));
        referral.setRecipientId((String) recipient.get("id"));
        referral.setTimestamp(String.valueOf(timestamp));

        publishMessage("messenger.referral.received", referral);
    }

    private void processWebhookOptin(Map<String, Object> event, Map<String, Object> sender,
                                     Map<String, Object> recipient, Long timestamp) {
        Map<String, Object> optinData = (Map<String, Object>) event.get("optin");

        FacebookMessengerOptin optin = new FacebookMessengerInboundAdapter.FacebookMessengerOptin();
        optin.senderId = (String) sender.get("id");
        optin.recipientId = (String) recipient.get("id");
        optin.ref = (String) optinData.get("ref");
        optin.userRef = (String) optinData.get("user_ref");
        optin.timestamp = String.valueOf(timestamp);
        publishMessage("messenger.optin.received", optin);
    }

    private void processWebhookDelivery(Map<String, Object> event, Map<String, Object> sender,
                                        Map<String, Object> recipient, Long timestamp) {
        Map<String, Object> deliveryData = (Map<String, Object>) event.get("delivery");

        FacebookMessengerDelivery delivery = new FacebookMessengerInboundAdapter.FacebookMessengerDelivery();
        delivery.senderId = (String) sender.get("id");
        delivery.recipientId = (String) recipient.get("id");
        delivery.messageIds = (List<String>) deliveryData.get("mids");
        delivery.watermark = ((Number) deliveryData.get("watermark")).longValue();
        delivery.timestamp = String.valueOf(timestamp);
        publishMessage("messenger.delivery.received", delivery);
    }

    private void processWebhookRead(Map<String, Object> event, Map<String, Object> sender,
                                    Map<String, Object> recipient, Long timestamp) {
        Map<String, Object> readData = (Map<String, Object>) event.get("read");

        FacebookMessengerRead read = new FacebookMessengerInboundAdapter.FacebookMessengerRead();
        read.senderId = (String) sender.get("id");
        read.recipientId = (String) recipient.get("id");
        read.watermark = ((Number) readData.get("watermark")).longValue();
        read.timestamp = String.valueOf(timestamp);
        publishMessage("messenger.read.received", read);
    }

    private void processWebhookReaction(Map<String, Object> event, Map<String, Object> sender,
                                        Map<String, Object> recipient, Long timestamp) {
        Map<String, Object> reactionData = (Map<String, Object>) event.get("reaction");

        FacebookMessengerReaction reaction = new FacebookMessengerInboundAdapter.FacebookMessengerReaction();
        reaction.senderId = (String) sender.get("id");
        reaction.recipientId = (String) recipient.get("id");
        reaction.messageId = (String) reactionData.get("mid");
        reaction.action = (String) reactionData.get("action");
        reaction.emoji = (String) reactionData.get("emoji");
        reaction.reaction = (String) reactionData.get("reaction");
        reaction.timestamp = String.valueOf(timestamp);
        publishMessage("messenger.reaction.received", reaction);
    }

    @Override
    public boolean verifyWebhookSignature(String signature, String payload) {
        if(!StringUtils.hasText(signature) || !signature.startsWith("sha256 = ")) {
            return false;
        }

        try {
            String expectedSignature = signature.substring(7); // Remove "sha256 = " prefix
            String appSecret = (String) configuration.get("appSecret");

            Mac mac = Mac.getInstance("HmacSHA256");
            mac.init(new SecretKeySpec(appSecret.getBytes(StandardCharsets.UTF_8), "HmacSHA256"));
            byte[] hash = mac.doFinal(payload.getBytes(StandardCharsets.UTF_8));

            String calculatedSignature = bytesToHex(hash);
            return expectedSignature.equals(calculatedSignature);
        } catch(Exception e) {
            log.error("Error verifying webhook signature", e);
            return false;
        }
    }

    @Override
    protected String getAdapterType() {
        return "FACEBOOK_MESSENGER";
    }

    @Override
    protected List<String> getSupportedEventTypes() {
        return Arrays.asList(
                "SOCIAL_MEDIA_MESSAGE",
                "SOCIAL_MEDIA_POSTBACK",
                "SOCIAL_MEDIA_REFERRAL",
                "SOCIAL_MEDIA_OPTIN",
                "SOCIAL_MEDIA_DELIVERY",
                "SOCIAL_MEDIA_READ",
                "SOCIAL_MEDIA_REACTION",
                "SOCIAL_MEDIA_INSIGHTS"
       );
    }

    private FacebookMessengerUser extractUserInfo(Map<String, Object> user) {
        if(user == null) {
            return null;
        }
        return FacebookMessengerUser.builder()
                .id((String) user.get("id"))
                .name((String) user.get("name"));
    }

    private List<FacebookMessengerAttachment> extractAttachments(List<Map<String, Object>> attachmentsList) {
        if(attachmentsList == null || attachmentsList.isEmpty()) {
            return new ArrayList<>();
        }

        List<FacebookMessengerAttachment> attachments = new ArrayList<>();
        for(Map<String, Object> attachmentData : attachmentsList) {
            FacebookMessengerAttachment attachment = new FacebookMessengerInboundAdapter.FacebookMessengerAttachment();
        attachment.type = (String) attachmentData.get("type");
        attachment.payload = attachmentData.get("payload");
            attachments.add(attachment);
        }
        return attachments;
    }

    private List<String> extractQuickReplies(List<Map<String, Object>> quickRepliesList) {
        if(quickRepliesList == null || quickRepliesList.isEmpty()) {
            return new ArrayList<>();
        }

        List<String> quickReplies = new ArrayList<>();
        for(Map<String, Object> quickReply : quickRepliesList) {
            String payload = (String) quickReply.get("payload");
            if(payload != null) {
                quickReplies.add(payload);
            }
        }
        return quickReplies;
    }

    private FacebookMessengerReferral extractReferral(Map<String, Object> referralData) {
        if(referralData == null) {
            return null;
        }

        return FacebookMessengerReferral.builder()
                .ref((String) referralData.get("ref"))
                .source((String) referralData.get("source"))
                .type((String) referralData.get("type"))
                .adId((String) referralData.get("ad_id"));
    }

    private String bytesToHex(byte[] bytes) {
        StringBuilder result = new StringBuilder();
        for(byte b : bytes) {
            result.append(String.format("%02x", b));
        }
        return result.toString();
    }

    private String makeGetRequest(String url, Map<String, String> params) {
        try {
            StringBuilder urlBuilder = new StringBuilder(url);
            if(!params.isEmpty()) {
                urlBuilder.append("?");
                params.forEach((key, value) ->
                    urlBuilder.append(key).append(" = ").append(value).append("&"));
                urlBuilder.setLength(urlBuilder.length() - 1); // Remove trailing &
            }

            ResponseEntity<String> response = restTemplate.getForEntity(
                urlBuilder.toString(), String.class);
            return response.getBody();
        } catch(Exception e) {
            log.error("Error making GET request to: {}", url, e);
            return " {}";
        }
    }

    private Map<String, Object> parseJsonResponse(String json) {
        try {
            return objectMapper.readValue(json, Map.class);
        } catch(Exception e) {
            log.error("Error parsing JSON response", e);
            return new HashMap<>();
        }
    }

    private void handlePagination(Map<String, Object> responseData) {
        if(responseData.containsKey("paging") && responseData.get("paging") instanceof Map) {
            Map<String, Object> paging = (Map<String, Object>) responseData.get("paging");
            if(paging.containsKey("next")) {
                log.debug("More pages available: {}", paging.get("next"));
                // Could process next page if needed
            }
        }
    }

    private void publishMessage(String eventType, Object message) {
        Map<String, Object> event = new HashMap<>();
        event.put("type", eventType);
        event.put("data", message);
        event.put("timestamp", System.currentTimeMillis());

        // In a real implementation, this would publish to an event bus or message queue
        log.debug("Publishing event: {} with data: {}", eventType, message);

        // Could use Spring's ApplicationEventPublisher
        // eventPublisher.publishEvent(new CustomEvent(eventType, message));
    }

    // Data classes for Facebook Messenger entities
        public static class FacebookMessengerMessageDTO {
        private String messageId;
        private String conversationId;
        private FacebookMessengerUser from;
        private FacebookMessengerUser to;
        private String text;
        private List<FacebookMessengerAttachment> attachments;
        private List<String> quickReplies;
        private String replyTo;
        private boolean isEcho;
        private String timestamp;
    }

        public static class FacebookMessengerUser {
        private String id;
        private String name;
    }

        public static class FacebookMessengerAttachment {
        private String type;
        private Object payload;
    }

        public static class FacebookMessengerPostback {
        private String senderId;
        private String recipientId;
        private String payload;
        private String title;
        private FacebookMessengerReferral referral;
        private String timestamp;
    }

        public static class FacebookMessengerReferral {
        private String ref;
        private String source;
        private String type;
        private String adId;
        private String senderId;
        private String recipientId;
        private String timestamp;
    }

        public static class FacebookMessengerOptin {
        private String senderId;
        private String recipientId;
        private String ref;
        private String userRef;
        private String timestamp;
    }

        public static class FacebookMessengerDelivery {
        private String senderId;
        private String recipientId;
        private List<String> messageIds;
        private Long watermark;
        private String timestamp;
    }

        public static class FacebookMessengerRead {
        private String senderId;
        private String recipientId;
        private Long watermark;
        private String timestamp;
    }

        public static class FacebookMessengerReaction {
        private String senderId;
        private String recipientId;
        private String messageId;
        private String action;
        private String emoji;
        private String reaction;
        private String timestamp;
    }

        public static class FacebookMessengerInsight {
        private String metric;
        private Object value;
        private String endTime;
    }
    // Getters and Setters
    public Map<String, Object> getConfiguration() {
        return configuration;
    }
    public void setConfiguration(Map<String, Object> configuration) {
        this.configuration = configuration;
    }
    public RestTemplate getRestTemplate() {
        return restTemplate;
    }
    public ObjectMapper getObjectMapper() {
        return objectMapper;
    }
    public ApplicationEventPublisher getEventPublisher() {
        return eventPublisher;
    }
    public Set<String> getProcessedMessages() {
        return processedMessages;
    }
    public Set<String> getProcessedPostbacks() {
        return processedPostbacks;
    }
    public String getMessageId() {
        return messageId;
    }
    public void setMessageId(String messageId) {
        this.messageId = messageId;
    }
    public String getConversationId() {
        return conversationId;
    }
    public void setConversationId(String conversationId) {
        this.conversationId = conversationId;
    }
    public FacebookMessengerUser getFrom() {
        return from;
    }
    public void setFrom(FacebookMessengerUser from) {
        this.from = from;
    }
    public FacebookMessengerUser getTo() {
        return to;
    }
    public void setTo(FacebookMessengerUser to) {
        this.to = to;
    }
    public String getText() {
        return text;
    }
    public void setText(String text) {
        this.text = text;
    }
    public List<FacebookMessengerAttachment> getAttachments() {
        return attachments;
    }
    public void setAttachments(List<FacebookMessengerAttachment> attachments) {
        this.attachments = attachments;
    }
    public List<String> getQuickReplies() {
        return quickReplies;
    }
    public void setQuickReplies(List<String> quickReplies) {
        this.quickReplies = quickReplies;
    }
    public String getReplyTo() {
        return replyTo;
    }
    public void setReplyTo(String replyTo) {
        this.replyTo = replyTo;
    }
    public boolean isIsEcho() {
        return isEcho;
    }
    public void setIsEcho(boolean isEcho) {
        this.isEcho = isEcho;
    }
    public String getTimestamp() {
        return timestamp;
    }
    public void setTimestamp(String timestamp) {
        this.timestamp = timestamp;
    }
    public String getId() {
        return id;
    }
    public void setId(String id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getType() {
        return type;
    }
    public void setType(String type) {
        this.type = type;
    }
    public Object getPayload() {
        return payload;
    }
    public void setPayload(Object payload) {
        this.payload = payload;
    }
    public String getSenderId() {
        return senderId;
    }
    public void setSenderId(String senderId) {
        this.senderId = senderId;
    }
    public String getRecipientId() {
        return recipientId;
    }
    public void setRecipientId(String recipientId) {
        this.recipientId = recipientId;
    }
    public String getPayload() {
        return payload;
    }
    public String getTitle() {
        return title;
    }
    public void setTitle(String title) {
        this.title = title;
    }
    public FacebookMessengerReferral getReferral() {
        return referral;
    }
    public void setReferral(FacebookMessengerReferral referral) {
        this.referral = referral;
    }
// DUPLICATE:     public String getTimestamp() {
    //         return timestamp;
//     }
// DUPLICATE:     public void setTimestamp(String timestamp) {
    //         this.timestamp = timestamp;
//     }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    public String getSource() {
        return source;
    }
    public void setSource(String source) {
        this.source = source;
    }
    public String getAdId() {
        return adId;
    }
    public void setAdId(String adId) {
        this.adId = adId;
    }
// DUPLICATE:     public String getSenderId() {
    //         return senderId;
//     }
// DUPLICATE:     public void setSenderId(String senderId) {
    //         this.senderId = senderId;
//     }
// DUPLICATE:     public String getRecipientId() {
    //         return recipientId;
//     }
// DUPLICATE:     public void setRecipientId(String recipientId) {
    //         this.recipientId = recipientId;
//     }
// DUPLICATE:     public String getTimestamp() {
    //         return timestamp;
//     }
// DUPLICATE:     public void setTimestamp(String timestamp) {
    //         this.timestamp = timestamp;
//     }
// DUPLICATE:     public String getSenderId() {
    //         return senderId;
//     }
// DUPLICATE:     public void setSenderId(String senderId) {
    //         this.senderId = senderId;
//     }
// DUPLICATE:     public String getRecipientId() {
    //         return recipientId;
//     }
// DUPLICATE:     public void setRecipientId(String recipientId) {
    //         this.recipientId = recipientId;
//     }
    public String getUserRef() {
        return userRef;
    }
    public void setUserRef(String userRef) {
        this.userRef = userRef;
    }
// DUPLICATE:     public String getTimestamp() {
    //         return timestamp;
//     }
// DUPLICATE:     public void setTimestamp(String timestamp) {
    //         this.timestamp = timestamp;
//     }
// DUPLICATE:     public String getSenderId() {
    //         return senderId;
//     }
// DUPLICATE:     public void setSenderId(String senderId) {
    //         this.senderId = senderId;
//     }
// DUPLICATE:     public String getRecipientId() {
    //         return recipientId;
//     }
// DUPLICATE:     public void setRecipientId(String recipientId) {
    //         this.recipientId = recipientId;
//     }
    public List<String> getMessageIds() {
        return messageIds;
    }
    public void setMessageIds(List<String> messageIds) {
        this.messageIds = messageIds;
    }
    public Long getWatermark() {
        return watermark;
    }
    public void setWatermark(Long watermark) {
        this.watermark = watermark;
    }
// DUPLICATE:     public String getTimestamp() {
    //         return timestamp;
//     }
// DUPLICATE:     public void setTimestamp(String timestamp) {
    //         this.timestamp = timestamp;
//     }
// DUPLICATE:     public String getSenderId() {
    //         return senderId;
//     }
// DUPLICATE:     public void setSenderId(String senderId) {
    //         this.senderId = senderId;
//     }
// DUPLICATE:     public String getRecipientId() {
    //         return recipientId;
//     }
// DUPLICATE:     public void setRecipientId(String recipientId) {
    //         this.recipientId = recipientId;
//     }
// DUPLICATE:     public String getTimestamp() {
    //         return timestamp;
//     }
// DUPLICATE:     public void setTimestamp(String timestamp) {
    //         this.timestamp = timestamp;
//     }
    public String getAction() {
        return action;
    }
    public void setAction(String action) {
        this.action = action;
    }
    public String getEmoji() {
        return emoji;
    }
    public void setEmoji(String emoji) {
        this.emoji = emoji;
    }
    public String getReaction() {
        return reaction;
    }
    public void setReaction(String reaction) {
        this.reaction = reaction;
    }
    public String getMetric() {
        return metric;
    }
    public void setMetric(String metric) {
        this.metric = metric;
    }
    public Object getValue() {
        return value;
    }
    public void setValue(Object value) {
        this.value = value;
    }
    public String getEndTime() {
        return endTime;
    }
    public void setEndTime(String endTime) {
        this.endTime = endTime;
    }
}
